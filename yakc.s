; Generated by c86 (BYU-NASM) 5.1 (beta) from yakc.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
YKCtxSwCount:
	DW	0
YKIdleCount:
	DW	0
YKTickNum:
	DW	0
tcbCount:
	DW	0
	ALIGN	2
YKInitialize:
	; >>>>> Line:	12
	; >>>>> void YKInitialize(void){ 
	jmp	L_yakc_1
L_yakc_2:
	; >>>>> Line:	16
	; >>>>> tcbArray[ 
	mov	ax, word [tcbCount]
	mov	cx, 20
	imul	cx
	add	ax, tcbArray
	mov	si, ax
	add	si, 10
	mov	word [si], 3
	mov	sp, bp
	pop	bp
	ret
L_yakc_1:
	push	bp
	mov	bp, sp
	jmp	L_yakc_2
	ALIGN	2
YKIdleTask:
	; >>>>> Line:	23
	; >>>>> void YKIdleTask(void){ 
	jmp	L_yakc_4
L_yakc_5:
	; >>>>> Line:	28
	; >>>>> while(1){ 
	jmp	L_yakc_7
L_yakc_6:
	; >>>>> Line:	30
	; >>>>> YKIdleCount++; 
	inc	word [YKIdleCount]
L_yakc_9:
L_yakc_7:
	jmp	L_yakc_6
L_yakc_8:
	mov	sp, bp
	pop	bp
	ret
L_yakc_4:
	push	bp
	mov	bp, sp
	jmp	L_yakc_5
	ALIGN	2
addToQueue:
	; >>>>> Line:	33
	; >>>>> addToQueue(TCB * tcb, TCB* listHead){ 
	jmp	L_yakc_11
L_yakc_12:
	; >>>>> Line:	36
	; >>>>> if(listHead == 0) 
	mov	ax, word [bp+6]
	mov	word [bp-2], ax
	; >>>>> Line:	36
	; >>>>> if(listHead == 0) 
	mov	ax, word [bp+6]
	test	ax, ax
	jne	L_yakc_13
	; >>>>> Line:	37
	; >>>>> listHead = tcb; 
	mov	ax, word [bp+4]
	mov	word [bp+6], ax
	jmp	L_yakc_14
L_yakc_13:
	; >>>>> Line:	39
	; >>>>> while(tcb->priority < pos->priority){ 
	jmp	L_yakc_16
L_yakc_15:
	; >>>>> Line:	40
	; >>>>> pos = pos->next; 
	mov	si, word [bp-2]
	add	si, 14
	mov	ax, word [si]
	mov	word [bp-2], ax
	; >>>>> Line:	41
	; >>>>> if(pos == 0){ 
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_18
	; >>>>> Line:	42
	; >>>>> pos->next = tcb; 
	mov	si, word [bp-2]
	add	si, 14
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	43
	; >>>>> tcb->previous = pos; 
	mov	si, word [bp+4]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
	; >>>>> Line:	44
	; >>>>> tcb->next = 0; 
	mov	si, word [bp+4]
	add	si, 14
	mov	word [si], 0
	; >>>>> Line:	45
	; >>>>> return; 
	jmp	L_yakc_19
L_yakc_18:
L_yakc_16:
	mov	si, word [bp+4]
	add	si, 16
	mov	di, word [bp-2]
	add	di, 16
	mov	al, byte [di]
	cmp	al, byte [si]
	ja	L_yakc_15
L_yakc_17:
	; >>>>> Line:	48
	; >>>>> pos->previous->next = tcb; 
	mov	si, word [bp-2]
	add	si, 12
	mov	si, word [si]
	add	si, 14
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	49
	; >>>>> tcb->previous = pos->previous; 
	mov	si, word [bp-2]
	add	si, 12
	mov	di, word [bp+4]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
	; >>>>> Line:	50
	; >>>>> tcb->next = pos; 
	mov	si, word [bp+4]
	add	si, 14
	mov	ax, word [bp-2]
	mov	word [si], ax
	; >>>>> Line:	51
	; >>>>> pos->previous = tcb; 
	mov	si, word [bp-2]
	add	si, 12
	mov	ax, word [bp+4]
	mov	word [si], ax
L_yakc_14:
L_yakc_19:
	mov	sp, bp
	pop	bp
	ret
L_yakc_11:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_12
	ALIGN	2
YKNewTask:
	; >>>>> Line:	55
	; >>>>> KDelayTask(unsigned count){ 
	jmp	L_yakc_21
L_yakc_22:
	; >>>>> Line:	64
	; >>>>> tcbCount++; 
	inc	word [tcbCount]
	; >>>>> Line:	66
	; >>>>> tcbArray[tcbCount-1].priority = priority; 
	mov	ax, word [tcbCount]
	dec	ax
	mov	cx, 20
	imul	cx
	add	ax, tcbArray
	mov	si, ax
	add	si, 16
	mov	al, byte [bp+8]
	mov	byte [si], al
	; >>>>> Line:	67
	; >>>>> tcbArray[tcbCount-1].state = READY; 
	mov	ax, word [tcbCount]
	dec	ax
	mov	cx, 20
	imul	cx
	add	ax, tcbArray
	mov	si, ax
	add	si, 10
	mov	word [si], 3
	; >>>>> Line:	68
	; >>>>> tcbArray[tcbCount-1].taskFunction = task; 
	mov	ax, word [tcbCount]
	dec	ax
	mov	cx, 20
	imul	cx
	add	ax, tcbArray
	mov	si, ax
	add	si, 18
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	69
	; >>>>> tcbArray[tcbCount-1].context[0] = 0; 
	mov	ax, word [tcbCount]
	dec	ax
	mov	cx, 20
	imul	cx
	mov	si, ax
	add	si, tcbArray
	mov	word [si], 0
	; >>>>> Line:	70
	; >>>>> tcbArray[tcbCount-1].context[1] = taskStack; 
	mov	ax, word [tcbCount]
	dec	ax
	mov	cx, 20
	imul	cx
	add	ax, tcbArray
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	71
	; >>>>> tcbArray[tcbCount-1].context[2] = task; 
	mov	ax, word [tcbCount]
	dec	ax
	mov	cx, 20
	imul	cx
	add	ax, tcbArray
	mov	si, ax
	add	si, 4
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	72
	; >>>>> tcbArray[tcbCount-1].context[3] = 0; 
	mov	ax, word [tcbCount]
	dec	ax
	mov	cx, 20
	imul	cx
	add	ax, tcbArray
	mov	si, ax
	add	si, 6
	mov	word [si], 0
	; >>>>> Line:	73
	; >>>>> tcbArray[tcbCount-1].context[4] = 0x100; 
	mov	ax, word [tcbCount]
	dec	ax
	mov	cx, 20
	imul	cx
	add	ax, tcbArray
	mov	si, ax
	add	si, 8
	mov	word [si], 256
	; >>>>> Line:	75
	; >>>>> addToQueue(&tcbArray[tcbCount-1], readyHead); 
	push	word [readyHead]
	mov	ax, word [tcbCount]
	dec	ax
	mov	cx, 20
	imul	cx
	add	ax, tcbArray
	push	ax
	call	addToQueue
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_yakc_21:
	push	bp
	mov	bp, sp
	jmp	L_yakc_22
	ALIGN	2
YKRun:
	; >>>>> Line:	78
	; >>>>> void YKRun(void){ 
	jmp	L_yakc_24
L_yakc_25:
	; >>>>> Line:	80
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_24:
	push	bp
	mov	bp, sp
	jmp	L_yakc_25
	ALIGN	2
YKDelayTask:
	; >>>>> Line:	81
	; >>>>> void YKDelayTask(unsigned count){ 
	jmp	L_yakc_27
L_yakc_28:
	; >>>>> Line:	83
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_27:
	push	bp
	mov	bp, sp
	jmp	L_yakc_28
	ALIGN	2
YKEnterISR:
	; >>>>> Line:	85
	; >>>>> void YKEnterISR(void){ 
	jmp	L_yakc_30
L_yakc_31:
	; >>>>> Line:	87
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_30:
	push	bp
	mov	bp, sp
	jmp	L_yakc_31
	ALIGN	2
YKExitISR:
	; >>>>> Line:	88
	; >>>>> void YKExitISR(void){ 
	jmp	L_yakc_33
L_yakc_34:
	; >>>>> Line:	92
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_33:
	push	bp
	mov	bp, sp
	jmp	L_yakc_34
	ALIGN	2
YKScheduler:
	; >>>>> Line:	93
	; >>>>> void YKScheduler(void){ 
	jmp	L_yakc_36
L_yakc_37:
	; >>>>> Line:	96
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_36:
	push	bp
	mov	bp, sp
	jmp	L_yakc_37
	ALIGN	2
YKDispatcher:
	; >>>>> Line:	97
	; >>>>> void YKDispatcher(void){ 
	jmp	L_yakc_39
L_yakc_40:
	; >>>>> Line:	101
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_39:
	push	bp
	mov	bp, sp
	jmp	L_yakc_40
	ALIGN	2
YKSemCreate:
	; >>>>> Line:	102
	; >>>>> YKSEM* YKSemCreate(int initialValue){ 
	jmp	L_yakc_42
L_yakc_43:
	; >>>>> Line:	104
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_42:
	push	bp
	mov	bp, sp
	jmp	L_yakc_43
	ALIGN	2
YKSemPend:
	; >>>>> Line:	105
	; >>>>> void YKSemPend(YKSEM *semaphore){ 
	jmp	L_yakc_45
L_yakc_46:
	; >>>>> Line:	113
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_45:
	push	bp
	mov	bp, sp
	jmp	L_yakc_46
	ALIGN	2
YKSemPost:
	; >>>>> Line:	115
	; >>>>> void YKSemPost(YKSEM *semaphore){ 
	jmp	L_yakc_48
L_yakc_49:
	; >>>>> Line:	119
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_48:
	push	bp
	mov	bp, sp
	jmp	L_yakc_49
	ALIGN	2
YKQCreate:
	; >>>>> Line:	121
	; >>>>> YKQ *YKQCreate(void **start, unsigned size){ 
	jmp	L_yakc_51
L_yakc_52:
	; >>>>> Line:	124
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_51:
	push	bp
	mov	bp, sp
	jmp	L_yakc_52
	ALIGN	2
YKQPend:
	; >>>>> Line:	125
	; >>>>> void *YKQPend(YKQ *queue){ 
	jmp	L_yakc_54
L_yakc_55:
	; >>>>> Line:	132
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_54:
	push	bp
	mov	bp, sp
	jmp	L_yakc_55
	ALIGN	2
YKQPost:
	; >>>>> Line:	133
	; >>>>> int YKQPost(YKQ *queue, void *msg){ 
	jmp	L_yakc_57
L_yakc_58:
	; >>>>> Line:	143
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_57:
	push	bp
	mov	bp, sp
	jmp	L_yakc_58
	ALIGN	2
YKEventCreate:
	; >>>>> Line:	144
	; >>>>> YKEVENT *YKEventCreate(unsigned initialValue){ 
	jmp	L_yakc_60
L_yakc_61:
	; >>>>> Line:	147
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_60:
	push	bp
	mov	bp, sp
	jmp	L_yakc_61
	ALIGN	2
YKEventPend:
	; >>>>> Line:	148
	; >>>>> unsigned YKEventPend(YKEVENT *event, unsigned eventMask, int waitMode){ 
	jmp	L_yakc_63
L_yakc_64:
	; >>>>> Line:	153
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_63:
	push	bp
	mov	bp, sp
	jmp	L_yakc_64
	ALIGN	2
YKEventSet:
	; >>>>> Line:	154
	; >>>>> void  
	jmp	L_yakc_66
L_yakc_67:
	; >>>>> Line:	161
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_66:
	push	bp
	mov	bp, sp
	jmp	L_yakc_67
	ALIGN	2
YKEventReset:
	; >>>>> Line:	162
	; >>>>> void YKEventReset(YKEVENT *event, unsigned eventMask){ 
	jmp	L_yakc_69
L_yakc_70:
	; >>>>> Line:	164
	; >>>>> } 
	mov	sp, bp
	pop	bp
	ret
L_yakc_69:
	push	bp
	mov	bp, sp
	jmp	L_yakc_70
	ALIGN	2
readyHead:
	TIMES	2 db 0
blockedHead:
	TIMES	20 db 0
delayedHead:
	TIMES	20 db 0
tcbArray:
	TIMES	200 db 0
